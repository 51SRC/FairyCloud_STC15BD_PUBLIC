C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE SMARTCAR
OBJECT MODULE PLACED IN ..\hex\SmartCar.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\code\SmartCar.c PRINT(.\SmartCar.lst) TABS(2) OBJECT(..\hex\SmartCar.obj
                    -)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC15F4K60S4 系列 定时器1用作串口1的波特率发生器举例------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966-------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.GXWMCU.com --------------------------------------------*/
   9          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序        */
  10          /* 如果要在文章中应用此代码,请在文章中注明使用了STC的资料及程序        */
  11          /*---------------------------------------------------------------------*/
  12          
  13          //本示例在Keil开发环境下请选择Intel的8058芯片型号进行编译
  14          //若无特别说明,工作频率一般为11.0592MHz
  15          
  16          
  17          #include "STC15W4K58S4.h"
  18          #include "DHT11.h"
  19          
  20          #include "intrins.h"
  21          #include <string.h>  // 字符串处理头文件
  22          
  23          sbit LED = P3 ^ 2;  // LED
  24          sbit Buzzer = P5 ^ 4;  // 蜂鸣器  记得用一个三极管驱动哦
  25          
  26          bit busy;
  27          
  28          typedef char I8;
  29          typedef int I16;
  30          typedef long I32;
  31          typedef unsigned char U8; 
  32          
  33          U8 SRCHeader = 0x23;
  34          U8 xdata SRCCID[] = {"SRC00000000000003"};// 0x52, 0x43, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0
             -x30, 0x30, 0x30, 0x30, 0x30, 0x33
  35          
  36          U8  DATA_GET[55]={0};//缓冲区
  37          
  38          U8 CURRENT_LENGTH=0;
  39          
  40          static   unsigned int   Timer4_Count=1;
  41          
  42          
  43          
  44          #define FOSC 11059200L          //系统频率
  45          #define BAUD 115200             //串口波特率
  46          
  47          #define S1_S0 0x40              //P_SW1.6
  48          #define S1_S1 0x80              //P_SW1.7
  49          
  50          
  51          //void SendString(char *s);
  52          void DELAY_MS(unsigned int timeout);    //@11.0592MHz   1ms
  53          void DELAY_1MS() ;
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 2   

  54          //void SendData(char *s);
  55          void UART_TC (unsigned char *str);
  56          void UART_T (unsigned char UART_data); //定义串口发送数据变量
  57          void UART_R();//接受数据
  58          void ConnectServer();//连接服务器
  59          void USART_Init();
  60          void Device_Init();
  61          void SendAckData(U8 len, unsigned char *RES_DATA);
  62          void ConnectSuccess();
  63          void Timer4Init();
  64          unsigned char CheckBCC(unsigned char len, unsigned char *recv);
  65          void ResponseData(unsigned char len,unsigned char *RES_DATA);
  66          void Buzzer_Actions_Status(unsigned char status);
  67          void Led_Actions_Status(unsigned char status);
  68          void Timer0Init(void);
  69          
  70          
  71          void main(){
  72   1          P0M0 = 0x00;
  73   1          P0M1 = 0x00;
  74   1          P1M0 = 0x00;
  75   1          P1M1 = 0x00;
  76   1          P2M0 = 0x00;
  77   1          P2M1 = 0x00;
  78   1          P3M0 = 0x00;
  79   1          P3M1 = 0x00;
  80   1          P4M0 = 0x00;
  81   1          P4M1 = 0x00;
  82   1          P5M0 = 0x00;
  83   1          P5M1 = 0x00;
  84   1          P6M0 = 0x00;
  85   1          P6M1 = 0x00;
  86   1          P7M0 = 0x00;
  87   1          P7M1 = 0x00;
  88   1      
  89   1          Device_Init();
  90   1      
  91   1          USART_Init();
  92   1      
  93   1          ConnectServer();
  94   1      
  95   1          ConnectSuccess();
  96   1          
  97   1          Timer4Init();
  98   1            //  Timer0Init();
  99   1      
 100   1          while(1) {
 101   2            
 102   2            if(DHT11_Read_Data(&DATA_Temphui[0],&DATA_Temphui[1])==0)//温湿度检测
 103   2            {
 104   3              
 105   3               DATA_Temphui[2]=1;  
 106   3            }
 107   2          
 108   2      
 109   2          };
 110   1      }
 111          
 112          unsigned char CheckBCC(unsigned char len, unsigned char *recv){
 113   1          unsigned char bcc = 0x00;
 114   1          unsigned char i=0;
 115   1          for(i=0;i<len-1;i++)
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 3   

 116   1          {
 117   2              bcc^=recv[i];
 118   2          };
 119   1          return bcc;
 120   1      
 121   1      }
 122          
 123          void ResponseData(unsigned char len,unsigned char *RES_DATA) {
 124   1        
 125   1        if(len <25){
 126   2          return ;
 127   2        }
 128   1      
 129   1      
 130   1      //校验和
 131   1        if(CheckBCC(len, RES_DATA) == RES_DATA[len-1]){
 132   2        
 133   2           unsigned char dataCmdFlag = RES_DATA[2];         //命令标识
 134   2           unsigned char dataCmdAck = RES_DATA[3];          //应答标识
 135   2          // unsigned char dataCid[17] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x
             -00,0x00,0x00};   //唯一设备号
 136   2           unsigned char j=0;
 137   2           unsigned char dataEncryptFlag = RES_DATA[21];    //加密方式
 138   2           unsigned char dataUintLength = (RES_DATA[22] << 8) | RES_DATA[23];  //数据长度
 139   2        //   unsigned char xdata  dataTimestamp[6] = {0x00,0x00,0x00,0x00,0x00,0x00};  //时间数据
 140   2      
 141   2         //校验CID是否正确
 142   2           for(j=4;j<21;j++){
 143   3              if(SRCCID[j-4] != RES_DATA[j]){
 144   4               return;
 145   4             }
 146   3           }
 147   2          
 148   2           //校验长度是否正确
 149   2           if ((25 + dataUintLength) != len) {
 150   3              return ;
 151   3           }
 152   2           
 153   2      //     //保存时间
 154   2      //     for(j=0;j<6;j++){
 155   2      //       dataTimestamp[j] = RES_DATA[24+j];
 156   2      //     }
 157   2           
 158   2           if(dataCmdFlag == 0x01){//连接认证
 159   3             
 160   3           }else if(dataCmdFlag ==0x02){//实时信息主动上报
 161   3             
 162   3           }else if(dataCmdFlag ==0x03){//补发
 163   3             
 164   3           }else if(dataCmdFlag ==0x04){//设备登出
 165   3             
 166   3           }else if(dataCmdFlag ==0x05){//心跳
 167   3             
 168   3           }else if(dataCmdFlag ==0x80){//远程控制
 169   3      
 170   3             if(RES_DATA[30] == 0x02){//基础数据查询
 171   4                unsigned char  light_status = LED ? 0x02 : 0x01;
 172   4                unsigned char buzzy_status = Buzzer ? 0x02 : 0x01;
 173   4                unsigned char xdata ds[36] = {0X23, 0X23, 0X02, 0XFE, 0x53, 0x52, 0x43, 0x30, 0x30, 0x30, 0x30, 0x30,
             - 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33, 0x01, 0x00, 0x0B, 0x14, 0x05, 0x18, 0x15, 0x24, 0x38, 0x02, 0x00,
             - 0x00, 0x00, 0x00, 0x00};
 174   4                unsigned char dslen =36;
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 4   

 175   4              
 176   4                 
 177   4                ds[31] = DATA_Temphui[0];
 178   4                ds[32] =  DATA_Temphui[1];
 179   4                ds[33] = light_status;
 180   4                ds[34] = buzzy_status;
 181   4                
 182   4                if(dataCmdAck == 0xFE){
 183   5                  ds[3] = 0x01;//成功
 184   5                  
 185   5                }
 186   4               ds[dslen-1] = CheckBCC(dslen, ds);
 187   4                  SendAckData(dslen,ds);
 188   4      
 189   4               
 190   4               
 191   4             }else if(RES_DATA[30] == 0x03){//基础控制
 192   4                     
 193   4                 unsigned char light = RES_DATA[31];
 194   4                 unsigned char buzzy = RES_DATA[32];
 195   4             
 196   4                 if( light==0x02){
 197   5                    Led_Actions_Status(0);
 198   5                  }else if( light==0x01){
 199   5                    Led_Actions_Status(1);
 200   5                  }
 201   4                 
 202   4                 if( buzzy==0x02){
 203   5                    Buzzer_Actions_Status(0);
 204   5                 }else if( buzzy==0x01){
 205   5                    Buzzer_Actions_Status(1);
 206   5                 }
 207   4                 
 208   4                if(dataCmdAck == 0xFE){
 209   5                  RES_DATA[3] = 0x01;//成功
 210   5                
 211   5                }
 212   4                  RES_DATA[len-1] = CheckBCC(len, RES_DATA);
 213   4                  SendAckData(len,RES_DATA);
 214   4      
 215   4             
 216   4             }else if(RES_DATA[30] == 0x7F){//重启
 217   4                IAP_CONTR = 0X20;
 218   4             }
 219   3             
 220   3             
 221   3             
 222   3           }
 223   2           
 224   2          
 225   2        }
 226   1        
 227   1      }
 228          
 229          
 230          
 231          void DELAY_1MS() {
 232   1          unsigned char i, j;
 233   1      
 234   1          _nop_();
 235   1          _nop_();
 236   1          _nop_();
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 5   

 237   1          i = 11;
 238   1          j = 190;
 239   1          do
 240   1          {
 241   2              while (--j);
 242   2          } while (--i);
 243   1      
 244   1      
 245   1      }
 246          
 247          void DELAY_MS(unsigned int timeout)   //@11.0592MHz
 248          {
 249   1          int t = 0;
 250   1          while (t < timeout)
 251   1          {
 252   2              t++;
 253   2              DELAY_1MS();
 254   2          }
 255   1      }
 256          
 257          
 258          
 259          //初始化LED和蜂鸣器
 260          void Device_Init() {
 261   1      
 262   1          LED = 0;
 263   1          Buzzer = 0;
 264   1      }
 265          
 266          //初始化完成滴滴两声
 267          void ConnectSuccess(){
 268   1      
 269   1         LED = 1;
 270   1         Buzzer = 1;
 271   1         DELAY_MS(200);
 272   1          LED = 0;
 273   1          Buzzer = 0;
 274   1         DELAY_MS(200);
 275   1          LED = 1;
 276   1          Buzzer = 1;
 277   1         DELAY_MS(200);
 278   1          LED = 0;
 279   1          Buzzer = 0;
 280   1      
 281   1      }
 282          
 283          
 284          void USART_Init()
 285          {
 286   1      
 287   1      //   ACC = P_SW1;
 288   1      //    ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
 289   1      //    P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
 290   1      
 291   1          ACC = P_SW1;
 292   1          ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
 293   1          ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
 294   1          P_SW1 = ACC;
 295   1          SCON = 0x50;                //8位可变波特率
 296   1      
 297   1      //  ACC = P_SW1;
 298   1      //  ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=1
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 6   

 299   1      //  ACC |= S1_S1;               //(P1.6/RxD_3, P1.7/TxD_3)
 300   1      //  P_SW1 = ACC;
 301   1      
 302   1      
 303   1          AUXR = 0x40;                //定时器1为1T模式
 304   1          TMOD = 0x00;                //定时器1为模式0(16位自动重载)
 305   1          TL1 = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
 306   1          TH1 = (65536 - (FOSC/4/BAUD))>>8;
 307   1          TR1 = 1;                    //定时器1开始启动
 308   1          ES = 1;                     //使能串口中断
 309   1          EA = 1;
 310   1      
 311   1      }
 312          
 313          /*----------------------------
 314          UART 中断服务程序
 315          -----------------------------*/
 316          void Uart() interrupt 4 using 1
 317          {
 318   1          if (RI)
 319   1          {
 320   2              while(!RI);
 321   2              RI=0;
 322   2              UART_R();
 323   2              busy = 0;
 324   2      
 325   2          }
 326   1          if (TI)
 327   1          {
 328   2              while(!TI);
 329   2              TI = 0;                 //清除TI位
 330   2              busy = 0;               //清忙标志
 331   2          }
 332   1      }
 333          
 334          
 335          void UART_T (unsigned char UART_data) { //定义串口发送数据变量
 336   1          SBUF = UART_data; //将接收的数据发送回去
 337   1          while(!TI);   //检查发送中断标志位
 338   1          TI = 0;     //令发送中断标志位为0（软件清零）
 339   1      }
 340          
 341          
 342          void UART_TC (unsigned char *str) {
 343   1          while(*str != '\0') {
 344   2              UART_T(*str);
 345   2              *str++;
*** WARNING C275 IN LINE 345 OF ..\CODE\SMARTCAR.C: expression with possibly no effect
 346   2          }
 347   1          *str = 0;
 348   1      }
 349          
 350          
 351          //串口  接收ESP8266的串口数据，并校验数据的完整性9位
 352          
 353          void UART_R()
 354          {
 355   1          TL0 = 0x00;   //设置定时初值
 356   1        TH0 = 0xDC;   //设置定时初值
 357   1        TF0 = 0;    //清除TF0标志
 358   1        TR0 = 1;    //定时器0开始计时
 359   1        ET0 = 1;  //允许中断
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 7   

 360   1        
 361   1        
 362   1      
 363   1         DATA_GET[CURRENT_LENGTH]=SBUF;
 364   1         CURRENT_LENGTH++;
 365   1        
 366   1        
 367   1      
 368   1      }
 369          
 370          
 371          
 372          void SendAckData(U8 len, unsigned char *RES_DATA) {
 373   1        
 374   1          unsigned int i=0;
 375   1          for(i=0; i<len; i++)
 376   1          {
 377   2               
 378   2              SBUF=RES_DATA[i];
 379   2              while(!TI);   //检查发送中断标志位
 380   2                TI = 0; 
 381   2          }
 382   1      }
 383          
 384          
 385          //初始化ESP8266WiFi模块，并连接到服务器
 386          void ConnectServer() {
 387   1      
 388   1          DELAY_MS( 1000);
 389   1      
 390   1          UART_TC("+++\0"); // 退出透传模式
 391   1          DELAY_MS( 1000);
 392   1      
 393   1      //    UART_TC("AT+RST\r\n\0");  // 复位
 394   1      //    DELAY_MS(2000);
 395   1          
 396   1          UART_TC("AT+CWMODE=1\r\n\0"); // 这是设置STA模式
 397   1          DELAY_MS( 2500);
 398   1          
 399   1          UART_TC("AT+CIPMUX=0\r\n\0");  // 设置单连接模式
 400   1          DELAY_MS(1000);
 401   1      
 402   1          UART_TC("AT+CWJAP=\"Gunter\",\"{qwerty123}\"\r\n\0");  // 这一步便是连接wifi，延时的时间要长一些，否则
             -会等不到返回的信息。10s
 403   1          DELAY_MS(15000);
 404   1      
 405   1      
 406   1          UART_TC("AT+CIPSTART=\"TCP\",\"47.104.19.111\",4001\r\n\0");  // 连接到指定TCP服务器
 407   1          DELAY_MS( 5000);
 408   1      
 409   1          UART_TC("AT+CIPMODE=1\r\n\0"); // 设置透传模式
 410   1          DELAY_MS( 2000);
 411   1      
 412   1        // UART_TC("AT+SAVETRANSLINK=1,\"47.104.19.111\",4001,\"TCP\"\r\n\0"); // 保存TCP连接到flash，实现上电透
             -传
 413   1        // DELAY_MS(1000);
 414   1      
 415   1          UART_TC("AT+CIPSEND\r\n\0");   // 进入透传模式 准备模块与电脑进行互传数据
 416   1          DELAY_MS( 1000);
 417   1          
 418   1          
 419   1      
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 8   

 420   1      }
 421          
 422          void Timer4Init(void)   //5毫秒@11.0592MHz
 423          {
 424   1        T4T3M |= 0x20;    //定时器时钟1T模式
 425   1        T4L = 0x00;   //设置定时初值
 426   1        T4H = 0x28;   //设置定时初值
 427   1        T4T3M |= 0x80;    //定时器4开始计时
 428   1          IE2 |= 0x40;    //开定时器4中断
 429   1          EA=1;   //总中断开启
 430   1      }
 431          
 432          
 433          //10s自动上报温湿度
 434          void Timer4_interrupt() interrupt 20    //定时中断入口
 435          {
 436   1        
 437   1        U8 xdata RES_DATA[]= { 0X23, 0X23, 0X02, 0XFE, 0x53, 0x52, 0x43, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30
             -, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33, 0x01, 0x00, 0x0B, 0x14, 0x05, 0x18, 0x15, 0x24, 0x38, 0x02, 0X23, 0X24, 0X02
             -, 0X02, 0xB0};
 438   1      unsigned char RES_LEN= 36;
 439   1      
 440   1          if(Timer4_Count>=2000){
 441   2            
 442   2              
 443   2            unsigned char  light_status = LED ? 0x02 : 0x01;
 444   2            unsigned char buzzy_status = Buzzer ? 0x02 : 0x01;
 445   2          unsigned char j = 4;
 446   2          
 447   2      //      U8 *SRCCID = "SRC00000000000001";
 448   2      //    for(j=4;j<=21;j++){
 449   2      //      RES_DATA[j] = SRCCID[j-4];
 450   2      //    }   
 451   2          
 452   2            Timer4_Count = 1;
 453   2            
 454   2      
 455   2            if(DATA_Temphui[2]==1)
 456   2            {
 457   3                DATA_Temphui[2]=0;//复位将其  用于检测是否收到数据
 458   3                
 459   3            }
 460   2      
 461   2            RES_DATA[31] = DATA_Temphui[0];
 462   2            RES_DATA[32] =  DATA_Temphui[1];
 463   2            RES_DATA[33] = light_status;
 464   2            RES_DATA[34] = buzzy_status,
 465   2            RES_DATA[RES_LEN-1] = CheckBCC(RES_LEN, RES_DATA);
 466   2                
 467   2            SendAckData(RES_LEN,RES_DATA);
 468   2            
 469   2          }else{
 470   2            
 471   2          Timer4_Count++;
 472   2          }
 473   1          
 474   1      }
 475          
 476          
 477          
 478          
 479          
C51 COMPILER V8.02   SMARTCAR                                                              06/05/2020 00:15:53 PAGE 9   

 480          void Timer0Init(void)   //10毫秒@11.0592MHz
 481          {
 482   1        AUXR &= 0x7F;   //定时器时钟12T模式
 483   1        TMOD &= 0xF0;   //设置定时器模式
 484   1        TMOD |= 0x01;   //设置定时器模式
 485   1        TL0 = 0x00;   //设置定时初值
 486   1        TH0 = 0x04;   //设置定时初值
 487   1        TF0 = 0;    //清除TF0标志
 488   1        TR0 = 1;    //定时器0开始计时
 489   1        ET0 = 1;  //允许中断
 490   1      }
 491          
 492          
 493          
 494          /********************* Timer0中断函数************************/
 495          void timer0_int (void) interrupt 1
 496          {
 497   1        TL0 = 0x00;   //设置定时初值
 498   1        TH0 = 0x04;   //设置定时初值
 499   1        TF0 = 0;    //清除TF0标志
 500   1        TR0 = 0;    //定时器0开始计时
 501   1        ET0 = 0;  //允许中断
 502   1        
 503   1        ResponseData(CURRENT_LENGTH,DATA_GET);    
 504   1        CURRENT_LENGTH = 0;
 505   1            
 506   1      }
 507          
 508          
 509          void Led_Actions_Status(unsigned char status){
 510   1      
 511   1        if(status){
 512   2          LED = 0;
 513   2        }else{
 514   2          LED = 1;
 515   2        }
 516   1      
 517   1      }
 518          
 519          void Buzzer_Actions_Status(unsigned char status){
 520   1      
 521   1        if(status){
 522   2          Buzzer = 0;
 523   2        }else{
 524   2          Buzzer = 1;
 525   2        }
 526   1      
 527   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1299    ----
   CONSTANT SIZE    =    214    ----
   XDATA SIZE       =     18      72
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     59      23
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
