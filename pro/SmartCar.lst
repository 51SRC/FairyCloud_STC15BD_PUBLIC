C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE SMARTCAR
OBJECT MODULE PLACED IN ..\hex\SmartCar.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\code\SmartCar.c PRINT(.\SmartCar.lst) TABS(2) OBJECT(..\hex\SmartCar.obj
                    -)

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC15F4K60S4 系列 定时器1用作串口1的波特率发生器举例------------*/
   4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966-------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.GXWMCU.com --------------------------------------------*/
   9          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序        */
  10          /* 如果要在文章中应用此代码,请在文章中注明使用了STC的资料及程序        */
  11          /*---------------------------------------------------------------------*/
  12          
  13          //本示例在Keil开发环境下请选择Intel的8058芯片型号进行编译
  14          //若无特别说明,工作频率一般为11.0592MHz
  15          
  16          
  17          #include "STC15W4K58S4.h"
  18          #include "DHT11.h"
  19          
  20          #include "intrins.h"
  21          #include <string.h>  // 字符串处理头文件
  22          
  23          sbit LED = P3 ^ 2;  // 对应硬件连接
  24          sbit LOUND = P5 ^ 4;  // 对应硬件连接
  25          
  26          bit busy;
  27          
  28          typedef char I8;
  29          typedef int I16;
  30          typedef long I32;
  31          typedef unsigned char U8; 
  32          
  33          U8 DATA_LENGTH = 9;
  34          U8 DATA_GET[]=  { 0x7E, 0, 0, 0, 0, 0, 0, 0, 0x7E};
  35          U8 SRCHeader = 0x7E;
  36          U8 SRCTail = 0x7E;
  37          U8 SRCDeviceID = 0x03;
  38          U8 SRCAID = 0x01;
  39          U8 CURRENT_LENGTH=0;
  40          U8 go=0;
  41          static   unsigned int   Timer4_Count=1;
  42          unsigned char RES_DATA[]= { 0x7E, 0x00,0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7E};
  43          
  44          
  45          
  46          #define FOSC 11059200L          //系统频率
  47          #define BAUD 115200             //串口波特率
  48          
  49          #define S1_S0 0x40              //P_SW1.6
  50          #define S1_S1 0x80              //P_SW1.7
  51          
  52          
  53          void SendString(char *s);
  54          void SendDatas(char *s);
C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 2   

  55          void DELAY_MS(unsigned int timeout);    //@11.0592MHz   1ms
  56          void DELAY_1MS() ;
  57          void SendData(char *s);
  58          void UART_TC (unsigned char *str);
  59          void UART_T (unsigned char UART_data); //定义串口发送数据变量
  60          void UART_R();//接受数据
  61          void ConnectServer();//连接服务器
  62          void USART_Init();
  63          void Device_Init();
  64          void ResponseData(unsigned char *RES_DATA);
  65          unsigned char CheckData(unsigned char *CHECK_DATA);
  66          void sendAckData(unsigned char *RES_DATA);
  67          void ConnectSuccess();
  68          void Timer4Init();
  69          
  70          
  71          void main(){
  72   1          P0M0 = 0x00;
  73   1          P0M1 = 0x00;
  74   1          P1M0 = 0x00;
  75   1          P1M1 = 0x00;
  76   1          P2M0 = 0x00;
  77   1          P2M1 = 0x00;
  78   1          P3M0 = 0x00;
  79   1          P3M1 = 0x00;
  80   1          P4M0 = 0x00;
  81   1          P4M1 = 0x00;
  82   1          P5M0 = 0x00;
  83   1          P5M1 = 0x00;
  84   1          P6M0 = 0x00;
  85   1          P6M1 = 0x00;
  86   1          P7M0 = 0x00;
  87   1          P7M1 = 0x00;
  88   1      
  89   1          Device_Init();
  90   1      
  91   1          USART_Init();
  92   1      
  93   1          ConnectServer();
  94   1      
  95   1          ConnectSuccess();
  96   1          
  97   1          Timer4Init();
  98   1          while(1) {
  99   2            
 100   2            if(DHT11_Read_Data(&DATA_Temphui[0],&DATA_Temphui[1])==0)//温湿度检测
 101   2            {
 102   3              
 103   3               DATA_Temphui[2]=1;  
 104   3            }
 105   2          
 106   2      
 107   2          };
 108   1      }
 109          
 110          void DELAY_1MS() {
 111   1          unsigned char i, j;
 112   1      
 113   1          _nop_();
 114   1          _nop_();
 115   1          _nop_();
 116   1          i = 11;
C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 3   

 117   1          j = 190;
 118   1          do
 119   1          {
 120   2              while (--j);
 121   2          } while (--i);
 122   1      
 123   1      
 124   1      }
 125          
 126          void DELAY_MS(unsigned int timeout)   //@11.0592MHz
 127          {
 128   1          int t = 0;
 129   1          while (t < timeout)
 130   1          {
 131   2              t++;
 132   2              DELAY_1MS();
 133   2          }
 134   1      }
 135          
 136          
 137          
 138          //初始化LED和蜂鸣器
 139          void Device_Init() {
 140   1      
 141   1          LED = 0;
 142   1          LOUND = 0;
 143   1      }
 144          
 145          //初始化完成滴滴两声
 146          void ConnectSuccess(){
 147   1      
 148   1         LED = 1;
 149   1         LOUND = 1;
 150   1         DELAY_MS(200);
 151   1          LED = 0;
 152   1          LOUND = 0;
 153   1         DELAY_MS(200);
 154   1          LED = 1;
 155   1          LOUND = 1;
 156   1         DELAY_MS(200);
 157   1          LED = 0;
 158   1          LOUND = 0;
 159   1      
 160   1      }
 161          
 162          
 163          void USART_Init()
 164          {
 165   1      
 166   1      //   ACC = P_SW1;
 167   1      //    ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
 168   1      //    P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
 169   1      
 170   1          ACC = P_SW1;
 171   1          ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
 172   1          ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
 173   1          P_SW1 = ACC;
 174   1          SCON = 0x50;                //8位可变波特率
 175   1      
 176   1      //  ACC = P_SW1;
 177   1      //  ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=1
 178   1      //  ACC |= S1_S1;               //(P1.6/RxD_3, P1.7/TxD_3)
C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 4   

 179   1      //  P_SW1 = ACC;
 180   1      
 181   1      
 182   1          AUXR = 0x40;                //定时器1为1T模式
 183   1          TMOD = 0x00;                //定时器1为模式0(16位自动重载)
 184   1          TL1 = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
 185   1          TH1 = (65536 - (FOSC/4/BAUD))>>8;
 186   1          TR1 = 1;                    //定时器1开始启动
 187   1          ES = 1;                     //使能串口中断
 188   1          EA = 1;
 189   1      
 190   1      }
 191          
 192          /*----------------------------
 193          UART 中断服务程序
 194          -----------------------------*/
 195          void Uart() interrupt 4 using 1
 196          {
 197   1          if (RI)
 198   1          {
 199   2              while(!RI);
 200   2              RI=0;
 201   2              UART_R();
 202   2              busy = 0;
 203   2      
 204   2          }
 205   1          if (TI)
 206   1          {
 207   2              while(!TI);
 208   2              TI = 0;                 //清除TI位
 209   2              busy = 0;               //清忙标志
 210   2          }
 211   1      }
 212          
 213          
 214          /*----------------------------
 215          发送串口数据
 216          ----------------------------*/
 217          
 218          void  SendData(char *s)
 219          {
 220   1          unsigned int i=0;
 221   1      
 222   1          for(i=0; i<DATA_LENGTH; i++)
 223   1          {
 224   2               
 225   2              SBUF=s[i];
 226   2               while(!TI);    //检查发送中断标志位
 227   2              TI = 0; 
 228   2              }
 229   1      }
 230          
 231          void UART_T (unsigned char UART_data) { //定义串口发送数据变量
 232   1          SBUF = UART_data; //将接收的数据发送回去
 233   1          while(!TI);   //检查发送中断标志位
 234   1          TI = 0;     //令发送中断标志位为0（软件清零）
 235   1      }
 236          
 237          
 238          void UART_TC (unsigned char *str) {
 239   1          while(*str != '\0') {
 240   2              UART_T(*str);
C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 5   

 241   2              *str++;
*** WARNING C275 IN LINE 241 OF ..\CODE\SMARTCAR.C: expression with possibly no effect
 242   2          }
 243   1          *str = 0;
 244   1      }
 245          
 246          
 247          //串口  接收ESP8266的串口数据，并校验数据的完整性9位
 248          
 249          void UART_R()
 250          {
 251   1          if((CURRENT_LENGTH==0)&&(SBUF==0x7E))// 判断第一个是不是0x7e  不确定是不是尾部7e
 252   1           {go=1;}
 253   1      
 254   1            if((go==1)&&(CURRENT_LENGTH==1)&&(SBUF==0X7E))//第二个7e
 255   1               {CURRENT_LENGTH=0;} 
 256   1      
 257   1            if(go==1)  //9个字符可以运行了
 258   1            {
 259   2               DATA_GET[CURRENT_LENGTH]=SBUF;
 260   2              CURRENT_LENGTH++;
 261   2              
 262   2              
 263   2              if(CURRENT_LENGTH==DATA_LENGTH)
 264   2              {
 265   3                  CURRENT_LENGTH=0;
 266   3                  go = 0;
 267   3                  ResponseData(DATA_GET);
 268   3              }
 269   2            }
 270   1      
 271   1      }
 272          
 273          
 274          
 275          ///校验数据准确性 做CRC校验
 276          unsigned char CheckData(unsigned char *mes){
 277   1          unsigned char crc = 0;
 278   1          unsigned char len = 6;
 279   1          unsigned char i=0;
 280   1          unsigned char cs=0;
 281   1          unsigned char message[] = {0,0,0,0,0,0};
 282   1          unsigned char *s = message;
 283   1          for( cs=0;cs<len;cs++){
 284   2              
 285   2              s[cs] = mes[cs+1];
 286   2          }
 287   1          
 288   1          
 289   1          while(len--)
 290   1          {
 291   2              crc ^= *s++;
 292   2              for(i = 0;i < 8;i++)
 293   2              {
 294   3                  if(crc & 0x01)
 295   3                  {
 296   4                      crc = (crc >> 1) ^ 0x8c;
 297   4                  }
 298   3                  else crc >>= 1;
 299   3              }
 300   2          }
 301   1          return crc;
C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 6   

 302   1      }
 303          
 304          //处理接收到的数据
 305          void ResponseData(unsigned char *RES_DATA) {
 306   1      
 307   1          if((CheckData(RES_DATA) == RES_DATA[DATA_LENGTH-2]) && RES_DATA[1]== SRCDeviceID &&  RES_DATA[2]== SRC
             -AID && RES_DATA[4]== 0x01 ) {
 308   2      
 309   2              if(RES_DATA[3]==0x00 ) {
 310   3                  if(DATA_Temphui[2]==1){
 311   4                        RES_DATA[3]=0x04;//高两位数据 4代表温湿度指令
 312   4                        RES_DATA[5]= DATA_Temphui[0];//高两位数据
 313   4                        RES_DATA[6]= DATA_Temphui[1];//进制转换  低两位数据位
 314   4                      //  DATA_Temphui[2]=0;
 315   4                  } 
 316   3                  sendAckData(RES_DATA);
 317   3              } else  if(RES_DATA[3]==0x03 && RES_DATA[6]==0x02) {
 318   3                  LED = 1;
 319   3                  sendAckData(RES_DATA);
 320   3              } else  if(RES_DATA[3]==0x03 && RES_DATA[6]==0x01) {
 321   3                  LED = 0;
 322   3                  sendAckData(RES_DATA);
 323   3              } else if(RES_DATA[3]==0x02 && RES_DATA[6]==0x02) {
 324   3                  LOUND = 1;
 325   3                  sendAckData(RES_DATA);
 326   3              } else  if(RES_DATA[3]==0x02 && RES_DATA[6]==0x01) {
 327   3                  LOUND = 0;
 328   3                  sendAckData(RES_DATA);
 329   3              }
 330   2          }
 331   1      
 332   1      }
 333          
 334          //处理待发送的数据
 335          void sendAckData(unsigned char *RES_DATA) {
 336   1      
 337   1      
 338   1          unsigned char DATA_SEND[]= { 0x7E, 0x00,0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7E};
 339   1      
 340   1      
 341   1          DATA_SEND[0]= SRCHeader;
 342   1          DATA_SEND[1]= SRCDeviceID;
 343   1          DATA_SEND[2]= SRCAID;
 344   1          DATA_SEND[3]= RES_DATA[3];
 345   1          DATA_SEND[5]= RES_DATA[5];
 346   1          DATA_SEND[6]= RES_DATA[6];
 347   1          DATA_SEND[7]= CheckData(DATA_SEND);
 348   1      
 349   1          DATA_SEND[DATA_LENGTH-1]= SRCTail;
 350   1          
 351   1          SendData(DATA_SEND);
 352   1      
 353   1      }
 354          
 355          //初始化ESP8266WiFi模块，并连接到服务器
 356          void ConnectServer() {
 357   1      
 358   1          DELAY_MS( 1000);
 359   1      
 360   1          UART_TC("+++\0"); // 退出透传模式
 361   1          DELAY_MS( 1000);
 362   1      
C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 7   

 363   1      //    UART_TC("AT+RST\r\n\0");  // 复位
 364   1      //    DELAY_MS(2000);
 365   1          
 366   1          UART_TC("AT+CWMODE=1\r\n\0"); // 这是设置STA模式
 367   1          DELAY_MS( 2500);
 368   1          
 369   1          UART_TC("AT+CIPMUX=0\r\n\0");  // 设置单连接模式
 370   1          DELAY_MS(1000);
 371   1      
 372   1          UART_TC("AT+CWJAP=\"Gunter\",\"{qwerty123}\"\r\n\0");  // 这一步便是连接wifi，延时的时间要长一些，否则
             -会等不到返回的信息。10s
 373   1          DELAY_MS(10000);
 374   1      
 375   1      
 376   1          UART_TC("AT+CIPSTART=\"TCP\",\"47.104.19.111\",4001\r\n\0");  // 连接到指定TCP服务器
 377   1          DELAY_MS( 5000);
 378   1      
 379   1          UART_TC("AT+CIPMODE=1\r\n\0"); // 设置透传模式
 380   1          DELAY_MS( 2000);
 381   1      
 382   1        // UART_TC("AT+SAVETRANSLINK=1,\"47.104.19.111\",4001,\"TCP\"\r\n\0"); // 保存TCP连接到flash，实现上电透
             -传
 383   1        // DELAY_MS(1000);
 384   1      
 385   1          UART_TC("AT+CIPSEND\r\n\0");   // 进入透传模式 准备模块与电脑进行互传数据
 386   1          DELAY_MS( 1000);
 387   1      
 388   1          CURRENT_LENGTH=0;
 389   1          
 390   1          
 391   1      
 392   1      }
 393          
 394          void Timer4Init(void)   //5毫秒@11.0592MHz
 395          {
 396   1        T4T3M |= 0x20;    //定时器时钟1T模式
 397   1        T4L = 0x00;   //设置定时初值
 398   1        T4H = 0x28;   //设置定时初值
 399   1        T4T3M |= 0x80;    //定时器4开始计时
 400   1          IE2 |= 0x40;    //开定时器4中断
 401   1          EA=1;   //总中断开启
 402   1      }
 403          
 404          
 405          //10s自动上报温湿度
 406          void Timer4_interrupt() interrupt 20    //定时中断入口
 407          {
 408   1          if(Timer4_Count>=2000){
 409   2            Timer4_Count = 1;
 410   2            
 411   2            if(DATA_Temphui[2]==1){
 412   3                  RES_DATA[3]=0x04;//高两位数据 4代表温湿度指令
 413   3                  RES_DATA[5]= DATA_Temphui[0];//高两位数据
 414   3                  RES_DATA[6]= DATA_Temphui[1];//进制转换  低两位数据位
 415   3                //  DATA_Temphui[2]=0;
 416   3            } 
 417   2            
 418   2            sendAckData(RES_DATA);
 419   2          }else{
 420   2            
 421   2            Timer4_Count++;
 422   2          }
C51 COMPILER V8.02   SMARTCAR                                                              05/23/2020 18:07:04 PAGE 8   

 423   1      }
 424          
 425          
 426          
 427          //void Timer0Init(void)   //10毫秒@11.0592MHz
 428          //{
 429          //  AUXR &= 0x7F;   //定时器时钟12T模式
 430          //  TMOD &= 0xF0;   //设置定时器模式
 431          //  TMOD |= 0x01;   //设置定时器模式
 432          //  TL0 = 0x00;   //设置定时初值
 433          //  TH0 = 0xDC;   //设置定时初值
 434          //  TF0 = 0;    //清除TF0标志
 435          //  TR0 = 1;    //定时器0开始计时
 436          //  ET0 = 1;  //允许中断
 437          //}
 438          
 439          ///********************* Timer0中断函数************************/
 440          //void timer0_int (void) interrupt 1
 441          //{
 442          //   
 443          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1066    ----
   CONSTANT SIZE    =    157    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     27      33
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
